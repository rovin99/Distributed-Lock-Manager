syntax = "proto3";

package lock;

option go_package = "Distributed-Lock-Manager/proto";

// The lock service definition
service LockService {
  // Initialize a new client
  rpc ClientInit (client_init_args) returns (client_init_response) {}
  
  // Acquire a lock
  rpc LockAcquire (lock_args) returns (lock_response) {}
  
  // Release a lock
  rpc LockRelease (lock_args) returns (lock_response) {}
  
  // Append to a file
  rpc FileAppend (file_args) returns (file_response) {}
  
  // Renew lease for a lock
  rpc RenewLease (lease_args) returns (lease_response) {}
  
  // Server-to-server replication RPCs
  
  // Update the secondary server's lock state (Primary -> Secondary)
  rpc UpdateSecondaryState (replicated_state) returns (replication_response) {}
  
  // Heartbeat to check if primary is alive (Secondary -> Primary)
  rpc Ping (heartbeat_request) returns (heartbeat_response) {}
}

// Client initialization arguments
message client_init_args {
  int32 client_id = 1;
  string request_id = 2;  // Added for request tracking
}

// Client initialization response
message client_init_response {
  Status status = 1;
  string error_message = 2;
}

// Lock operation arguments
message lock_args {
  int32 client_id = 1;
  string token = 2;  // Token for lock validation
  string request_id = 3;  // Added for request tracking
}

// Lock operation response
message lock_response {
  Status status = 1;
  string error_message = 2;
  string token = 3;  // Token for future operations
}

// File operation arguments
message file_args {
  int32 client_id = 1;
  string filename = 2;
  bytes content = 3;
  string token = 4;  // Token for permission validation
  string request_id = 5;  // Added for request tracking
}

// File operation response
message file_response {
  Status status = 1;
  string error_message = 2;
}

// Lease renewal arguments
message lease_args {
  int32 client_id = 1;
  string token = 2;  // Token for lease validation
  string request_id = 3;  // Added for request tracking
}

// Lease renewal response
message lease_response {
  Status status = 1;
  string error_message = 2;
}

// Replicated state message for primary -> secondary communication
message replicated_state {
  int32 lock_holder = 1;    // ID of lock holder (-1 if free)
  string lock_token = 2;    // Current lock token
  int64 expiry_timestamp = 3; // Expiry time as unix timestamp
}

// Response to replication update
message replication_response {
  Status status = 1;
  string error_message = 2;
}

// Heartbeat request (secondary -> primary)
message heartbeat_request {
  int32 server_id = 1;  // ID of the secondary server
}

// Heartbeat response
message heartbeat_response {
  Status status = 1;
  string error_message = 2;
}

// Status codes for responses
enum Status {
  OK = 0;
  ERROR = 1;
  LOCK_HELD = 2;
  LOCK_NOT_HELD = 3;
  INVALID_TOKEN = 4;  // New status for token validation failures
  PERMISSION_DENIED = 5;  // New status for permission-related errors
  SERVER_FENCING = 6;  // Server is in fencing period after promotion
  SECONDARY_MODE = 7;  // Server is in secondary mode and can't process client requests
}
